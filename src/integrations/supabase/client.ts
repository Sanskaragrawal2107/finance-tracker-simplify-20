// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { Advance, Expense, FundsReceived, Invoice, ApprovalStatus } from '@/lib/types';

const SUPABASE_URL = "https://bpyzpnioddmzniuikbsn.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJweXpwbmlvZGRtem5pdWlrYnNuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3ODE0MzksImV4cCI6MjA1NzM1NzQzOX0.UEdE77tebNbCdJkmX0RyNpKVp3mWhTL-hekMVNcPuIg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      storageKey: 'finance-tracker-auth',
      storage: localStorage,
      autoRefreshToken: true,
      detectSessionInUrl: false, // Prevent issues with URL-based auth
    },
    global: {
      fetch: customFetch,
      headers: {
        'x-client-info': 'finance-tracker/1.0.0'
      }
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    }
  }
);

// Custom fetch function with retry mechanism for network errors
function customFetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
  // Add timeout to prevent hanging requests during tab switches
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 45000); // 45 second timeout
  
  const fetchWithTimeout = () => fetch(input, {
    ...init,
    signal: controller.signal
  }).finally(() => clearTimeout(timeoutId));
  
  return withRetry(fetchWithTimeout, 3, 1000, (error) => {
    // Retry on network errors but not on auth errors
    return error.name === 'AbortError' || 
           error.message?.includes('fetch') || 
           error.message?.includes('network');
  });
}

// Helper function to retry failed operations
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number,
  delay: number,
  retryCondition?: (error: any) => boolean
): Promise<T> {
  let lastError: any;
  let retries = 0;

  while (retries < maxRetries) {
    try {
      return await operation();
    } catch (error: any) {
      lastError = error;
      // Check if we should retry based on the error
      if (retryCondition && !retryCondition(error)) {
        break;
      }

      retries++;
      if (retries < maxRetries) {
        console.warn(`Operation failed, retrying (${retries}/${maxRetries})...`, error);
        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay * retries));
      }
    }
  }

  console.error(`Operation failed after ${maxRetries} retries:`, lastError);
  throw lastError;
}

// Function to ping Supabase and reconnect if needed
export const pingSupabase = async (): Promise<boolean> => {
  try {
    // Create abort controller with a short timeout to prevent hanging
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);
    
    const start = Date.now();
    const { data, error } = await supabase
      .from('users')
      .select('count')
      .limit(1)
      .abortSignal(controller.signal);
    
    // Clear the timeout since the request completed
    clearTimeout(timeoutId);
    
    const duration = Date.now() - start;
    console.log(`Supabase ping response time: ${duration}ms`);
    
    if (error) {
      console.error('Supabase ping failed:', error);
      return false;
    }
    
    // Reconnect Supabase realtime channels
    try {
      supabase.removeAllChannels();
      supabase.channel('system').subscribe();
      console.log('Reconnected Supabase channels');
    } catch (err) {
      console.error('Error reconnecting Supabase channels:', err);
    }
    
    return true;
  } catch (error) {
    // Special handling for AbortError (timeout)
    if (error.name === 'AbortError') {
      console.error('Supabase ping timed out');
    } else {
      console.error('Error pinging Supabase:', error);
    }
    return false;
  }
};

// Function to refresh schema cache - this was missing and causing errors
export const refreshSchemaCache = async () => {
  try {
    // Simple query to refresh the schema cache
    await supabase.from('users').select('id').limit(1);
    console.log('Schema cache refreshed');
    return { success: true };
  } catch (error) {
    console.error('Error refreshing schema cache:', error);
    return { success: false, error };
  }
};

// Fetch site invoices
export const fetchSiteInvoices = async (siteId: string): Promise<Invoice[]> => {
  try {
    const { data, error } = await supabase
      .from('site_invoices')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      partyId: item.party_id,
      partyName: item.party_name,
      material: item.material,
      quantity: item.quantity,
      rate: item.rate,
      gstPercentage: item.gst_percentage,
      grossAmount: item.gross_amount,
      netAmount: item.net_amount,
      materialItems: item.material_items ? JSON.parse(item.material_items) : [],
      bankDetails: item.bank_details ? JSON.parse(item.bank_details) : {},
      billUrl: item.bill_url || '',
      invoiceImageUrl: item.invoice_image_url || '',
      paymentStatus: item.payment_status as any,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      approverType: item.approver_type as "ho" | "supervisor" || "ho",
      siteId: item.site_id,
      vendorName: item.party_name,
      invoiceNumber: item.party_id,
      amount: item.net_amount,
      status: item.payment_status as any
    }));
  } catch (error) {
    console.error('Error fetching site invoices:', error);
    return [];
  }
};

// Fetch site expenses
export const fetchSiteExpenses = async (siteId: string): Promise<Expense[]> => {
  try {
    const { data, error } = await supabase
      .from('expenses')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      description: item.description || '',
      category: item.category,
      amount: item.amount,
      status: item.status as ApprovalStatus || ApprovalStatus.PENDING,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      siteId: item.site_id,
      supervisorId: item.supervisor_id || ''
    }));
  } catch (error) {
    console.error('Error fetching site expenses:', error);
    return [];
  }
};

// Fetch site advances
export const fetchSiteAdvances = async (siteId: string): Promise<Advance[]> => {
  try {
    const { data, error } = await supabase
      .from('advances')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      recipientId: item.recipient_id || undefined,
      recipientName: item.recipient_name,
      recipientType: item.recipient_type,
      purpose: item.purpose,
      amount: item.amount,
      remarks: item.remarks || '',
      status: item.status as ApprovalStatus,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      siteId: item.site_id
    }));
  } catch (error) {
    console.error('Error fetching site advances:', error);
    return [];
  }
};

// Fetch site funds received
export const fetchSiteFundsReceived = async (siteId: string): Promise<FundsReceived[]> => {
  try {
    const { data, error } = await supabase
      .from('funds_received')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      amount: item.amount,
      siteId: item.site_id,
      createdAt: new Date(item.created_at),
      reference: item.reference || '',
      method: item.method || ''
    }));
  } catch (error) {
    console.error('Error fetching site funds received:', error);
    return [];
  }
};

// Delete expense
export const deleteExpense = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('expenses')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting expense:', error);
    return { success: false, error };
  }
};

// Delete advance
export const deleteAdvance = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('advances')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting advance:', error);
    return { success: false, error };
  }
};

// Delete funds received
export const deleteFundsReceived = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('funds_received')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting funds received:', error);
    return { success: false, error };
  }
};

// Delete invoice
export const deleteInvoice = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('site_invoices')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting invoice:', error);
    return { success: false, error };
  }
};
