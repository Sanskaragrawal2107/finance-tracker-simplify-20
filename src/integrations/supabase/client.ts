// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { Advance, Expense, FundsReceived, Invoice, ApprovalStatus } from '@/lib/types';

const SUPABASE_URL = "https://bpyzpnioddmzniuikbsn.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJweXpwbmlvZGRtem5pdWlrYnNuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3ODE0MzksImV4cCI6MjA1NzM1NzQzOX0.UEdE77tebNbCdJkmX0RyNpKVp3mWhTL-hekMVNcPuIg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      storageKey: 'finance-tracker-auth',
      storage: localStorage,
      autoRefreshToken: true,
      detectSessionInUrl: true, // enable URL-based session detection to keep tokens in sync
    },
    global: {
      headers: {
        'x-client-info': 'finance-tracker/1.0.0'
      }
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    }
  }
);

// Proactive helper to ensure a fresh session
export async function ensureFreshSession(): Promise<boolean> {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const nowSec = Math.floor(Date.now() / 1000);
    const expiresAt = session?.expires_at ?? 0;
    // If no session or expiring in <= 15s, refresh
    if (!session || expiresAt - nowSec <= 15) {
      const { data, error } = await supabase.auth.refreshSession();
      return !!data?.session && !error;
    }
    return true;
  } catch {
    return false;
  }
}

// Observe and log session changes (helps diagnose token loss on tab switches)
supabase.auth.onAuthStateChange((_event, session) => {
  if (session) {
    console.log('Supabase auth state changed. New token ends with:', session.access_token?.slice(-8));
  } else {
    console.warn('Supabase auth state changed. No active session');
  }
});


// Function to refresh schema cache - this was missing and causing errors
export const refreshSchemaCache = async () => {
  try {
    // Simple query to refresh the schema cache
    await supabase.from('users').select('id').limit(1);
    console.log('Schema cache refreshed');
    return { success: true };
  } catch (error) {
    console.error('Error refreshing schema cache:', error);
    return { success: false, error };
  }
};

// Fetch site invoices
export const fetchSiteInvoices = async (siteId: string): Promise<Invoice[]> => {
  try {
    const { data, error } = await supabase
      .from('site_invoices')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      partyId: item.party_id,
      partyName: item.party_name,
      material: item.material,
      quantity: item.quantity,
      rate: item.rate,
      gstPercentage: item.gst_percentage,
      grossAmount: item.gross_amount,
      netAmount: item.net_amount,
      materialItems: item.material_items ? JSON.parse(item.material_items) : [],
      bankDetails: item.bank_details ? JSON.parse(item.bank_details) : {},
      billUrl: item.bill_url || '',
      invoiceImageUrl: item.invoice_image_url || '',
      paymentStatus: item.payment_status as any,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      approverType: item.approver_type as "ho" | "supervisor" || "ho",
      siteId: item.site_id,
      vendorName: item.party_name,
      invoiceNumber: item.party_id,
      amount: item.net_amount,
      status: item.payment_status as any
    }));
  } catch (error) {
    console.error('Error fetching site invoices:', error);
    return [];
  }
};

// Fetch site expenses
export const fetchSiteExpenses = async (siteId: string): Promise<Expense[]> => {
  try {
    const { data, error } = await supabase
      .from('expenses')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      description: item.description || '',
      category: item.category,
      amount: item.amount,
      status: item.status as ApprovalStatus || ApprovalStatus.PENDING,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      siteId: item.site_id,
      supervisorId: item.supervisor_id || ''
    }));
  } catch (error) {
    console.error('Error fetching site expenses:', error);
    return [];
  }
};

// Fetch site advances
export const fetchSiteAdvances = async (siteId: string): Promise<Advance[]> => {
  try {
    const { data, error } = await supabase
      .from('advances')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      recipientId: item.recipient_id || undefined,
      recipientName: item.recipient_name,
      recipientType: item.recipient_type,
      purpose: item.purpose,
      amount: item.amount,
      remarks: item.remarks || '',
      status: item.status as ApprovalStatus,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      siteId: item.site_id
    }));
  } catch (error) {
    console.error('Error fetching site advances:', error);
    return [];
  }
};

// Fetch site funds received
export const fetchSiteFundsReceived = async (siteId: string): Promise<FundsReceived[]> => {
  try {
    const { data, error } = await supabase
      .from('funds_received')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      amount: item.amount,
      siteId: item.site_id,
      createdAt: new Date(item.created_at),
      reference: item.reference || '',
      method: item.method || ''
    }));
  } catch (error) {
    console.error('Error fetching site funds received:', error);
    return [];
  }
};

// Delete expense
export const deleteExpense = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('expenses')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting expense:', error);
    return { success: false, error };
  }
};

// Delete advance
export const deleteAdvance = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('advances')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting advance:', error);
    return { success: false, error };
  }
};

// Delete funds received
export const deleteFundsReceived = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('funds_received')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting funds received:', error);
    return { success: false, error };
  }
};

// Delete invoice
export const deleteInvoice = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('site_invoices')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting invoice:', error);
    return { success: false, error };
  }
};
