
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { Advance, Expense, FundsReceived, Invoice, ApprovalStatus, SupervisorTransaction } from '@/lib/types';

const SUPABASE_URL = "https://bpyzpnioddmzniuikbsn.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJweXpwbmlvZGRtem5pdWlrYnNuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3ODE0MzksImV4cCI6MjA1NzM1NzQzOX0.UEdE77tebNbCdJkmX0RyNpKVp3mWhTL-hekMVNcPuIg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Function to refresh schema cache - this was missing and causing errors
export const refreshSchemaCache = async () => {
  try {
    // Simple query to refresh the schema cache
    await supabase.from('users').select('id').limit(1);
    console.log('Schema cache refreshed');
    return { success: true };
  } catch (error) {
    console.error('Error refreshing schema cache:', error);
    return { success: false, error };
  }
};

// Fetch site invoices
export const fetchSiteInvoices = async (siteId: string): Promise<Invoice[]> => {
  try {
    const { data, error } = await supabase
      .from('site_invoices')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      partyId: item.party_id,
      partyName: item.party_name,
      material: item.material,
      quantity: item.quantity,
      rate: item.rate,
      gstPercentage: item.gst_percentage,
      grossAmount: item.gross_amount,
      netAmount: item.net_amount,
      materialItems: item.material_items ? JSON.parse(item.material_items) : [],
      bankDetails: item.bank_details ? JSON.parse(item.bank_details) : {},
      billUrl: item.bill_url || '',
      invoiceImageUrl: item.invoice_image_url || '',
      paymentStatus: item.payment_status as any,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      approverType: item.approver_type as "ho" | "supervisor" || "ho",
      siteId: item.site_id,
      vendorName: item.party_name,
      invoiceNumber: item.party_id,
      amount: item.net_amount,
      status: item.payment_status as any
    }));
  } catch (error) {
    console.error('Error fetching site invoices:', error);
    return [];
  }
};

// Fetch site expenses
export const fetchSiteExpenses = async (siteId: string): Promise<Expense[]> => {
  try {
    const { data, error } = await supabase
      .from('expenses')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      description: item.description || '',
      category: item.category,
      amount: item.amount,
      status: item.status as ApprovalStatus || ApprovalStatus.PENDING,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      siteId: item.site_id,
      supervisorId: item.supervisor_id || ''
    }));
  } catch (error) {
    console.error('Error fetching site expenses:', error);
    return [];
  }
};

// Fetch site advances
export const fetchSiteAdvances = async (siteId: string): Promise<Advance[]> => {
  try {
    const { data, error } = await supabase
      .from('advances')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      recipientId: item.recipient_id || undefined,
      recipientName: item.recipient_name,
      recipientType: item.recipient_type,
      purpose: item.purpose,
      amount: item.amount,
      remarks: item.remarks || '',
      status: item.status as ApprovalStatus,
      createdBy: item.created_by || '',
      createdAt: new Date(item.created_at),
      siteId: item.site_id
    }));
  } catch (error) {
    console.error('Error fetching site advances:', error);
    return [];
  }
};

// Fetch site funds received
export const fetchSiteFundsReceived = async (siteId: string): Promise<FundsReceived[]> => {
  try {
    const { data, error } = await supabase
      .from('funds_received')
      .select('*')
      .eq('site_id', siteId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      amount: item.amount,
      siteId: item.site_id,
      createdAt: new Date(item.created_at),
      reference: item.reference || '',
      method: item.method || ''
    }));
  } catch (error) {
    console.error('Error fetching site funds received:', error);
    return [];
  }
};

// Fetch supervisor transactions
export const fetchSupervisorTransactions = async (siteId?: string, supervisorId?: string): Promise<SupervisorTransaction[]> => {
  try {
    let query = supabase
      .from('supervisor_transactions')
      .select(`
        id,
        date,
        amount,
        transaction_type,
        created_at,
        payer_supervisor_id,
        receiver_supervisor_id,
        payer_site_id,
        receiver_site_id,
        payer_users:payer_supervisor_id(name),
        receiver_users:receiver_supervisor_id(name)
      `)
      .order('date', { ascending: false });

    // Filter by site if provided
    if (siteId) {
      query = query.or(`payer_site_id.eq.${siteId},receiver_site_id.eq.${siteId}`);
    }

    // Filter by supervisor if provided
    if (supervisorId) {
      query = query.or(`payer_supervisor_id.eq.${supervisorId},receiver_supervisor_id.eq.${supervisorId}`);
    }

    const { data, error } = await query;

    if (error) throw error;

    return data.map((item: any) => ({
      id: item.id,
      date: new Date(item.date),
      payerSupervisorId: item.payer_supervisor_id,
      payerSupervisorName: item.payer_users?.name || 'Unknown',
      receiverSupervisorId: item.receiver_supervisor_id,
      receiverSupervisorName: item.receiver_users?.name || 'Unknown',
      payerSiteId: item.payer_site_id,
      receiverSiteId: item.receiver_site_id,
      amount: Number(item.amount),
      transactionType: item.transaction_type,
      createdAt: new Date(item.created_at)
    }));
  } catch (error) {
    console.error('Error fetching supervisor transactions:', error);
    return [];
  }
};

// Delete supervisor transaction
export const deleteSupervisorTransaction = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('supervisor_transactions')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting supervisor transaction:', error);
    return { success: false, error };
  }
};

// Delete expense
export const deleteExpense = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('expenses')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting expense:', error);
    return { success: false, error };
  }
};

// Delete advance
export const deleteAdvance = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('advances')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting advance:', error);
    return { success: false, error };
  }
};

// Delete funds received
export const deleteFundsReceived = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('funds_received')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting funds received:', error);
    return { success: false, error };
  }
};

// Delete invoice
export const deleteInvoice = async (id: string, userId: string) => {
  try {
    const { error } = await supabase
      .from('site_invoices')
      .delete()
      .eq('id', id);

    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting invoice:', error);
    return { success: false, error };
  }
};
